from base64 import urlsafe_b64decode
from cerberus import Validator
from tempfile import mktemp
from pathlib import Path
import azure.durable_functions as df
import logging
import os


schema = {
    "steps": {
        "type": "list",
        "required": True,
        "schema": {
            "type": "dict",
            "schema": {
                "name": {
                    "type": "string",
                    "required": True,
                },
                "code": {
                    "type": "string",
                    "required": True,
                },
                "config": {
                    "type": "string",
                    "required": True,
                },
                "requirements": {
                    "type": "string",
                    "required": True,
                    "nullable": True,
                }
            },
        },
    },
}


def info(msg: str):
    logging.info(f"orchestrator: {msg}")


# TODO: pass through a GUID generated by initiator for consistent logging.
def _orchestrator(context: df.DurableOrchestrationContext):
    """Orchestrates the execution of a pipeline's SAME steps."""
    input = context.get_input()
    if input is None:  # should never happen, it's only triggered by us
        raise Exception("no input provided to orchestrator.")

    validator = Validator(schema)
    if not validator.validate(input):
        raise SyntaxError(f"input is invalid: {validator.errors}")

    # TODO: handle multiple steps, requirements, docker image etc.
    session_context = None
    for step in input["steps"]:
        try:
            code = urlsafe_b64decode(step["code"]).decode("utf-8")
        except Exception as err:
            raise Exception(
                f"'code' field of input should be urlsafe_b64encoded string: {err}")

        data = {"code": code}
        if session_context is not None:
            data["session_context"] = session_context

        result = yield context.call_activity("executor", data)
        session_context = result["session_context"]

    return result

orchestrator = df.Orchestrator.create(_orchestrator)

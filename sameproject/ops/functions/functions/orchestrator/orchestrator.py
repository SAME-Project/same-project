from base64 import urlsafe_b64decode
from cerberus import Validator
from tempfile import mktemp
from pathlib import Path
import azure.durable_functions as df
import logging
import os


schema = {
    "steps": {
        "type": "list",
        "required": True,
        "schema": {
            "type": "string",
        },
    },
}


def info(msg: str):
    logging.info(f"orchestrator: {msg}")


# TODO: pass through a GUID generated by initiator for consistent logging.
def _orchestrator(context: df.DurableOrchestrationContext):
    """Orchestrates the execution of a pipeline's SAME steps."""
    input = context.get_input()
    if input is None:  # should never happen, it's only triggered by us
        raise Exception("no input provided to orchestrator.")

    validator = Validator(schema)
    if not validator.validate(input):
        raise SyntaxError(f"input is invalid: {validator.errors}")

    # TODO: handle multiple steps, requirements, docker image etc.
    namespace = None
    for step in input["steps"]:
        try:
            code = urlsafe_b64decode(step).decode("utf-8")
        except Exception as err:
            raise Exception(
                f"'code' field of input should be urlsafe_b64encoded string: {err}")

        req = {"code": code}
        if namespace is not None:
            req["namespace"] = namespace

        info("passing code to executor...")
        result = yield context.call_activity("executor", req)

        info(f"code successfully executed: {result}")
        namespace = result["namespace"]

    return result

orchestrator = df.Orchestrator.create(_orchestrator)

{% autoescape off %}import kfp.v2.components
from kfp.v2.dsl import InputPath
from kubernetes.client.models import V1EnvVar
from kubernetes import client, config
from typing import NamedTuple
from base64 import b64encode
import kfp.v2.dsl as dsl
import kubernetes
import json
import kfp

from run_info import run_info_fn
{% for step in list_of_steps %}
from {{ step.unique_step_name }} import {{ step.unique_step_name }}_fn
{% endfor %}


run_info_comp = kfp.v2.dsl.component(
    func=run_info_fn,
    packages_to_install=[
        "kfp",
        "dill",
    ],
)

{% for step in list_of_steps %}
{{ step.unique_step_name }}_comp = kfp.v2.dsl.component(
    func={{ step.unique_step_name }}_fn,
    base_image="{{ step.image_tag }}",
    packages_to_install=[
        "dill",
        "requests",
        {{ step.package_string }} # TODO: make this a loop
    ],
)
{% endfor %}

@kfp.dsl.pipeline(name="root_pipeline_compilation",)
def root(
    context: str='', metadata_url: str='',
):
    # Generate secrets (if not already created)
    secrets_by_env = {}
{% for env_name in secrets_to_create_as_dict %}
{% set secret = secrets_to_create_as_dict[env_name] %}
    config.load_kube_config()
    v1 = client.CoreV1Api()
    namespace = "kubeflow"
    name = "{{ experiment_name_safe }}"
    metadata = {"name": name, "namespace": "kubeflow"}
    api_version = "v1"
    kind = "Secret"
    type = "kubernetes.io/dockerconfigjson"

    cred_payload = {
        "auths": {
    		    "{{secret.image_pull_secret_registry_uri}}": {
    			      "username": "{{secret.image_pull_secret_username}}",
    			      "password": "{{secret.image_pull_secret_password}}",
    			      "email": "{{secret.image_pull_secret_email}}",
    			      "auth": b64encode(
    				        f"{{secret.image_pull_secret_username}}:{{secret.image_pull_secret_password}}".encode()
    			      ).decode(),
    		    }
    	  }
    }

    data = {
        ".dockerconfigjson": b64encode(json.dumps(cred_payload).encode()).decode()
    }

    body = client.V1Secret(
        api_version="v1",
        data=data,
        kind="Secret",
        metadata=metadata,
        type=type,
    )
    api_response = None
    try:
        api_response = v1.create_namespaced_secret(namespace, body)
    except kubernetes.client.rest.ApiException as e:
        if e.status == 409:
            if (
                cred_payload["auths"]
    		    	  and cred_payload["auths"]["{{secret.image_pull_secret_registry_uri}}"]
    		    	  and cred_payload["auths"]["{{secret.image_pull_secret_registry_uri}}"]["username"]
    		    	  and cred_payload["auths"]["{{secret.image_pull_secret_registry_uri}}"]["password"]
    		    	  and cred_payload["auths"]["{{secret.image_pull_secret_registry_uri}}"]["email"]
    		    ):
    		        api_response = v1.replace_namespaced_secret(name, namespace, body)
            else:
                print(f"Missing value")
        else:
            raise e
    
    dsl.get_pipeline_conf().set_image_pull_secrets([client.V1LocalObjectReference(name=name)])
{% endfor %}

    env_vars = {
    }

    run_info = run_info_comp(run_id=kfp.dsl.RUN_ID_PLACEHOLDER)


{% for step in list_of_steps %}
    {{ step.unique_step_name }} = {{ step.unique_step_name }}_comp(
{% if step.previous_step_name %}
        input_context_path={{ step.previous_step_name }}.outputs["output_context_path"],
{% else %}
        input_context_path="",
{% endif %}
        run_info=run_info.outputs["run_info"],
        metadata_url=metadata_url
    )

{% if step.previous_step_name %}
    {{ step.unique_step_name }}.after({{ step.previous_step_name }})
{% endif %}
    {{ step.unique_step_name }}.execution_options.caching_strategy.max_cache_staleness = "P0D"
    for k in env_vars:
        {{ step.unique_step_name }}.add_env_variable(V1EnvVar(name=k, value=env_vars[k]))
{% endfor %}

{% endautoescape %}
